/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   Complex XML search in a compressed dictionary via .bwi and
   retrieval of the document occurrences.

   bwxml_new.c   
   P. Ferragina, 16 May 2001

   Details: This software assumes that there is a home directory that
   is structured as follows. It has subdirectories: Index, Reduced,
   Collections, Working. Index contains all data and indexes useful
   for searching (e.g. <nomecoll>_entities.db, Tabfiles.xse). Reduced contains
   the reduced versions of the indexed files. Collections contains the
   indexed files in their original xml form. Working contains all the
   files generated by the search engine after the query. Notice that
   the first three dirs contain other subdirs, one per collection. So
   given a collection named <coll_name>, all of its data and idices
   are enclosed in: 

   - $HOME_FMX/Index/<coll_name>
   - $HOME_FMX/Reduced/<coll_name>
   - $HOME_FMX/Collections/<coll_name>

   The $HOME_FMX dir is provided directly via the -o option, or it is
   set as an environment variable.
   >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

#include "common.h"
#include "MG_common.h"
#include <ctype.h>

/* --- external vars and Macros --- */ 
extern uchar Inv_map_sb[256];  // inverse map for the current superbucket
extern int Alpha_size_sb;      // actual size of alphabet in superbucket
extern double Cache_percentage;  // size of cache (% wrt uncompressed size)


#define EOF_shift(n) (n < s->bwt_eof_pos) ? n+1 :  n

/* --- word search strategy with errors --- */ 
#define ERRORLETTER       4 // 1-edit distance with letters

char *Type_search[6] =  {
  "Substring",
  "Prefix",
  "Suffix",
  "Word",
  "Word with 1 letter error",
  "Word with 1 error"
};


/* ---- Data type for collecting word occurrences in a dictionary ---- */
typedef struct {
  int rank;
  int row;
  char word[300];
}  dict_occ;


/* ---- Data type for collecting doc occurrences from the Inveted Lists ---- */
// You can find it  into MG_common.h
// typedef struct{int doc;int pattern;char word[256];char *doc_name;}docs_occ;


// BitMask for the presence of *** And  Htag Ltag Cdata Attr_name Attr_val patt
//                             128  64   32   16    8      4         2       1

// Single Bit Masks which indicate the presence of the arguments
uchar AND_mask = 64;				
uchar Htag_mask = 32;				
uchar Ltag_mask = 16;
uchar Cdata_mask = 8;
uchar Attr_name_mask = 4;
uchar Attr_value_mask = 2;

#define NUM_MASKS 7

uchar Search_mask[NUM_MASKS] =  {
  22,   // Ltag + Attr_name + Attr_value
  48,   // Htag + Ltag
  16,   // Ltag
  80,   // Ltag + pattern(s)
  64,   // multi-pattern searches
  72,   // Cdata + pattern(s)
  88    // Cdata + tag + pattern(s)
};

			
#define MAX_AND_PATTERNS 10
       
/* ---- "local" global variables for the type of the search ---- */
char *Htag,*Ltag,*Attr_name,*Attr_value;
int AND_type_search[MAX_AND_PATTERNS];                
char *AND_string_type;
uchar *AND_pattern[MAX_AND_PATTERNS];
int Start_tag,End_tag,Num_rank_end,Word_rank_start;


/* ---- comparison functions to sort list of occurrences --- */
int rank_cmp(const void *a, const void *b)
{ return (((dict_occ *)a)->rank - ((dict_occ *)b)->rank);}

int doc_cmp(const void *a, const void *b)
{ return (((docs_occ *)a)->doc - ((docs_occ *)b)->doc); }

int doc_word_name_cmp(const void *a, const void *b)
{ 
  int x = (((docs_occ *)a)->doc - ((docs_occ *)b)->doc);
  int y = strcmp(((docs_occ *)a)->word,((docs_occ *)b)->word);

  if (x==0) {return y;} else {return x;}
}




/* *******************************************************************
   This is similar to bwsearch procedure in search_main.c The
    difference resides in the fact that we are operating on a
    dictionary and assume to have various types of pattern searches:
    word prefix, word suffix, word enclosure and full word. The first
    part of the procedure modify the returned pattern to reflect these
    kind of searches since dictionary words are separated by NULL.
   ******************************************************************* */
int search_pattern_dict(bwi_out *s, uchar *p, int len, int *sp, int *ep, int wsearch)
{
  int i;
  uchar c, *ptemp;

  ptemp = strdup(p);

  /* ---- remap pattern ------ */
  assert(len>0);
  for(i=0;i<len;i++) {
    if(s->bool_char_map[p[i]]==0) return 0;  /* char not in file */
    ptemp[i]= s->char_map[p[i]];                  /* remap char */
  }
  
  /* ---- get initial sp and ep values ----- */ 
  if ((wsearch == WFULL) || (wsearch == WSUFFIX))   // suffix or word
    { i = len; c = s->char_map[0]; }
  else 
    { i=len-1; c=ptemp[i];}

  *sp=s->bwt_occ[c];
  if(c==s->alpha_size-1)
    *ep=s->text_size-1;
  else 
    *ep=s->bwt_occ[c+1]-1;   

  /* ----- main loop (see paper) ---- */
  while((*sp <= *ep) && (i>0)) {
    c=ptemp[--i];
    *sp = s->bwt_occ[c]+occ(s, EOF_shift(*sp - 1), c);
    *ep = s->bwt_occ[c]+occ(s, EOF_shift(*ep), c)-1;
  }

  if ((i==0) && ((wsearch == WPREFIX) || (wsearch == WFULL)))  // prefix or word
    { 
      c = s->char_map[0];
      *sp = s->bwt_occ[c]+occ(s, EOF_shift(*sp - 1), c);
      *ep = s->bwt_occ[c]+occ(s, EOF_shift(*ep), c)-1;
    }

  /* ----- return number of occurrences ----- */
  free(ptemp);
  if(*ep < *sp) return 0;
  return(*ep - *sp + 1);
}


/* **********************************************************
   This is the procedure to retrieve the rank of the word which
   "contains" the position where the present row start.  Recall that
   we have marked (a fraction of) the rows which start with the NULL
   char. The main loop consists in checking if the current row is
   marked (that is, starts with NULL and is 0 modulo s->skip). If it
   is not, we appy the LF mapping to get the row corresponding to the
   previous char.
   ********************************************************** */
int get_rank(bwi_out *s, int row)
{
  void get_info_sb(bwi_out *,int,int *);
  uchar get_info_b(bwi_out *,uchar,int,int *,int);
  uchar c,c_sb;
  int len,occ_sb[256],occ_b[256],n,curr_row;
  int null_occ, counted_null, delta, null_start_row;
  
  assert(s->skip!=0);
  // ------ compute number of bits used for each rank 
  if(s->chosen_char==s->alpha_size-1)
    null_occ = s->text_size-s->bwt_occ[s->chosen_char];
  else
    null_occ = s->bwt_occ[s->chosen_char+1] - s->bwt_occ[s->chosen_char];
  assert(null_occ>0 && null_occ < s->text_size);
  len = int_log2(null_occ);

  // ----- compute start of marked rows and current row
  null_start_row = s->bwt_occ[s->chosen_char];
  curr_row = row;
  counted_null = 0;

  /* ---- search row starting with NULL and marked  ----- */ 
  while(1){
    delta = curr_row - null_start_row;
    if(delta>=0 && delta<null_occ) {
      // ---- curr_row starts with a NULL ----
      if((delta % s->skip)==0) {
	// the row is marked! retrieve its position
	n = delta/s->skip;     // Rescale
	my_fseek(Infile, ((n*len)/8) + Start_prologue_occ,SEEK_SET);
	init_bit_buffer();
	if((n*len) % 8)
	  bit_read( (n*len) % 8);  // skip bits not belonging to this pos  
	// return the rank + number of skipped NULL
	return(bit_read(len) + counted_null); 
      }
      else
	counted_null++; // not marked 
    }

    // ----- special case: beginning of file --------
    if (curr_row == s->bwt_eof_pos) // we know that s->text[0]=NULL hence
      return (counted_null-1);      // counted_null has been just incremntd 
 
    /* ------------------------------------------------------------- 
       now we search the row corresponding to the preceeding char
       ------------------------------------------------------------- */
    // fetches info from the header of the superbucket
    get_info_sb(s,EOF_shift(curr_row),occ_sb);  

    // fetches occ into occ_b properly remapped and returns
    // the remapped code for occ_b of the char in the 
    // specified position
    c = get_info_b(s,NULL_CHAR,EOF_shift(curr_row),occ_b,WHAT_CHAR_IS);  
    assert(c < Alpha_size_sb);

    // Inverse Remapping: bucket --> superbucket --> remapped_text
    c_sb = Inv_map_sb[c];
    assert(c_sb < s->alpha_size);

    // Compute # occ of character c before the position given above
    n = occ_sb[c_sb] + occ_b[c] - 1;

    // compute the corresponding row
    curr_row = s->bwt_occ[c_sb] + n;

  }
  fatal_error("Fatal error: This code should not be reached (get_rank)\n");
  exit(1);
}


/* *************************************************************************
   This is the basic procedure to search in a dictionary of words. It
   is directly derived from huffw.c by taking only the part of the
   source code referring to the computation of the pattern rank.
   ************************************************************************* */
dict_occ *search_dict(uchar *pattern, int pat_len, int type_search, int *num_occ)
{
  int start_pos_occ,end_pos_occ,i,j;
  dict_occ *list_occ;
  bwi_out s_main;
  bwi_out *s = &s_main; 

  /* ---------  get all matching words occurrences ------------- */
  read_basic_prologue(s);
  *num_occ = search_pattern_dict(s, pattern, pat_len, &start_pos_occ, 
				 &end_pos_occ,type_search);
  if(*num_occ==0)
    return NULL;            // no codes to return

  /* ---------  accumulate all dictionary ranks in an array ------------- */
  list_occ = (dict_occ *) malloc(sizeof(dict_occ) * (*num_occ));
  if(list_occ == NULL)
    fatal_error("Fatal error: --- search_dict ----\n");
  for(i = 0; i < *num_occ; i++){
    list_occ[i].rank = get_rank(s, start_pos_occ+i);
    list_occ[i].row = start_pos_occ+i;
  }

  /* ---------  sort the ranks ------------- */
  qsort(list_occ, *num_occ, sizeof(dict_occ), rank_cmp);

  /* --------- Clean the list of occurrences ----------- */
  if(type_search==WSUBSTRING) {        // check for multiple in-word occs
    for(j=0, i=1; i < *num_occ; i++) {
      if (list_occ[i].rank != list_occ[j].rank){  // Not a duplicate ...
	list_occ[++j].rank = list_occ[i].rank;   // ... save it
	list_occ[j].row = list_occ[i].row;   
      } 
    }
    assert(j < *num_occ);
    *num_occ = j+1;                     // number of actual occs
  }
  return(list_occ);
}




/* *********************************************************************
   read chars before the position given by row using the LF mapping
   stop if the beginning of the file, or a NULL char, is encountered.
   write in *len the number of read characters.
   ********************************************************************* */
void get_prefix_word(int row, int *len, char *dest, bwi_out *s)
{
  int curr_row,n;
  uchar c,c_sb;
  int occ_sb[256],occ_b[256];
  
  curr_row=row;
  for(*len=0;; ) {
    // fetches info from the header of the superbucket
    get_info_sb(s,curr_row,occ_sb);  
    // fetches occ into occ_b properly remapped and returns
    // the remapped code for occ_b of the char in the  specified position
    c = get_info_b(s,NULL_CHAR,curr_row,occ_b,WHAT_CHAR_IS);  
    assert(c < Alpha_size_sb);
    c_sb = Inv_map_sb[c];
    assert(c_sb < s->alpha_size);
    if(s->inv_char_map[c_sb] == 0)  break;
    dest[(*len)++] = s->inv_char_map[c_sb]; // store char    
    n = occ_sb[c_sb] + occ_b[c] - 1;         // # of occ before curr_row
    curr_row = s->bwt_occ[c_sb] + n;         // get next row
    if(curr_row==s->bwt_eof_pos) break;    
    curr_row = EOF_shift(curr_row);        
  }
}

/* *******************************************************
   write in dest the chars of "row" (unless the EOF or NULL are
   encountered).  *len keeps the number of read characters
   ******************************************************* */
void get_suffix_word(int row, int *len, int plen, char *dest, bwi_out *s)
{
  uchar get_firstcolumn_char(int row, bwi_out *s);
  int fl_map(int,uchar,bwi_out *);
  uchar c;

  for(*len=0;;) {
    c = get_firstcolumn_char(row,s);
    assert(c<s->alpha_size);
    
    if(*len > plen-1){
      if(s->inv_char_map[c] == 0){ // skip prefix
	*len -= plen;
	return ;
      }
      dest[(*len) - plen] = s->inv_char_map[c];
    }
    *len += 1;
    // compute the first to last mapping
    row = fl_map(row,c,s);
    // adjust row to take the EOF symbol into account
    if(row<=s->bwt_eof_pos) row -= 1;
    if(row<0){ // skip prefix
	*len -= plen;
	return ;
      }
  }
}


/* ------- Build the tag-string to search ------- */

void Build_tagstring(uchar Curr_mask, char *tag_string)
{

  switch(Curr_mask) {

  case 22:                  // Ltag + Attr_name + Attr_value
    // <tag&<attr_name=...attr_value...
    sprintf(tag_string,"<%s&<%s=",Ltag,Attr_name);
    break;

  case 48:                  // Htag + Ltag
    // <Htag<Ltag>
    sprintf(tag_string,"<%s<%s>",Htag,Ltag);
    break;

  case 16:                  // Ltag
    // <Ltag&>
    sprintf(tag_string,"<%s&>",Ltag);
    break;
    
  case 80:                  // Ltag + pattern(s)
    // <Ltag#....pattern....
    sprintf(tag_string,"<%s#",Ltag);
    break;

  case 72:                  // Cdata + pattern(s)
    // <<<....pattern....
    strcpy(tag_string,"<<<");
    break;

  case 88:                  // Cdata + tag + pattern(s)
    // <<Ltag#...pattern...
    sprintf(tag_string,"<<%s#",Ltag);
    break;

  default: // ... pattern ...  (no tag or attribute to search for) 
    tag_string[0] = '\0';
    break;
  };
}


/* ------- Expand the pattern strings to search It stores in
 list_word_occ[i] all the words (row and ranks) which expand
 AND_pattern[i]. Their number is stored in num_occ_word[i].
 ---------------------------- */

void Build_pattern(bwi_out *s, int i, int *num_occ_word, dict_occ **list_occ_word)
{
  int t,c,j;
  char word_prefix[256],word_suffix[256];
  char *pattern;
  int pattlen;
  int *num_occ;
  dict_occ *patt_occ;

  // list_occ_word is sorted for increasing rank 
  list_occ_word[i] = search_dict(AND_pattern[i],strlen(AND_pattern[i]),
				 AND_type_search[i],&(num_occ_word[i]));

  pattern = AND_pattern[i];
  pattlen = strlen(pattern);
  patt_occ = list_occ_word[i];
  num_occ = num_occ_word+i;

  // Filter out the pattern occurrences which are not words
  c = 0;
  for(j=0;j < *num_occ; j++){
    if ((patt_occ[j].rank <= Num_rank_end) ||
	(patt_occ[j].rank >= Word_rank_start))
      {
	patt_occ[c].rank = patt_occ[j].rank;
	patt_occ[c++].row = patt_occ[j].row;
      }
  }
  *num_occ=c;
  
  // Compute the entire words corresponding to retrieved ranks
  for(j=0;j < *num_occ; j++){
    
    switch (AND_type_search[i]){
      
    case WPREFIX:      // We searched for a prefix, and need the suffix
      sprintf(patt_occ[j].word,"%s",pattern);
      get_suffix_word(patt_occ[j].row,&c,pattlen+1,word_suffix, s);
      strncat(patt_occ[j].word,word_suffix,c);
      patt_occ[j].word[pattlen+c] = 0;
      break;
      
    case WSUFFIX:    // We searched for a suffix, and need the prefix
      get_prefix_word(patt_occ[j].row, &c, word_prefix, s);
      for(t=0; t<c; t++)
	patt_occ[j].word[t] = word_prefix[c-t-1];
      patt_occ[j].word[c] = 0;
      strcat(patt_occ[j].word,pattern);
      break;
      
    case WSUBSTRING: // We searched for a substring, hence need prefix and suffix
      get_prefix_word(patt_occ[j].row, &c, word_prefix, s);
      for(t=0; t<c; t++)
	patt_occ[j].word[t] = word_prefix[c-t-1];
      patt_occ[j].word[c] = 0;
      strcat(patt_occ[j].word,pattern);
      get_suffix_word(patt_occ[j].row, &c,pattlen,word_suffix, s);
      strncat(patt_occ[j].word,word_suffix,c);
      break;
      
    case WFULL:    // We searched for a full word, hence need nothing
      sprintf(patt_occ[j].word,"%s",pattern);
      break;
    }
  }
}



/* ------------------- Compute the prefix of actual length
   "prefix_len" by considering entities as singletons -------------- */

int Get_actual_length(int i, char *pattern)
{
  int actual,counted;
  char *p,*q;

  for(actual=0,counted=0; counted < i; counted++)
    {
      if(pattern[actual] != 'X'){
	actual++;
      } else {  
	p=strstr(pattern+actual,"X038");  // Check where & occurs
	q=strstr(pattern+actual,"X059");  // Check where ; occurs
	if((p==pattern+actual) && (q != NULL)){  // We have found an entity &...;
	  actual += (q-p+4);
	} else { actual += 4; }
      }
    }
  return(actual);
}


/* ------- Search for 1-edit distance pattern ------- */
// It stores in list_word_occ[0] all the words (row and ranks) which
// match AND_pattern[0] with 1 error. Their number is stored in
// num_occ_word[0]. An error can be given by an entity name taken from
// the file <nomecoll>_entities.db or by any letter stored in this
// file.  Singletons are letters/digits or X??? or entities
// X038....X059
// ---------------------------------------------------------------
void Build_erroneous_pattern(int k, int *number, dict_occ **list_occ, char *path, char *coll_name)
{
  int i,t,c,j,n,len,actual_len;
  dict_occ *temp_list;
  uchar temp_string[500];
  FILE *entity_file;
  char **entities, l[255], *p, *q;
  char entity[255],temp_entity[255];
  int num_entities;


  /* ------------- Load the substitutions: entities or letters or .... -------------- */
  num_entities = 0;
  entities = NULL;
  sprintf(temp_string,"%s/Index/%s/%s_entities.db",path,coll_name,coll_name);
  if((entity_file=fopen(temp_string,"r")) == NULL)
    fatal_error("Fatal Error: No file ..../Index/<coll>/<coll>_entities.db");

  
  // Compute their number
  while((fgets(l,255,entity_file)) != NULL){
    if((strstr(l,"<!ENTITY") == l) || (strstr(l,"<!LETTER") == l))
      num_entities++;
  }
  
  // Allocate space for them
  entities = (char **) malloc(sizeof(char *) * num_entities);
  if(entities == NULL)
    fatal_error("Fatal error: --- out of memory in entities allocation ----\n");
  
  // Fetches the entities and the letters
  fseek(entity_file,0,SEEK_SET);
  i=0;
  while((fgets(l,255,entity_file)) != NULL){
    if(l[0] == (char)47) continue; // jump a comment line
    
    p = strpbrk(l," \t");
    q = strpbrk(p+1," \t");
    if ((p==NULL) || (q==NULL))
      fatal_error("Fatal error: getting entities from <coll>_entities.db");
    
    strncpy(temp_entity,p+1,(int)(q-p-1));
    temp_entity[(int)(q-p-1)]=0;
    
    if(strstr(l,"<!LETTER") != NULL)
      { sprintf(entity,"%s",temp_entity); }
    else { sprintf(entity,"X038%sX059",temp_entity); }
    entities[i] = strdup(entity);
    i++;
  }
  fclose(entity_file);


  /* ----------  Determines the erroneous patterns  -------------- */
  
  len = strlen(AND_pattern[k]);
  list_occ[k] = (dict_occ *) malloc(sizeof(dict_occ) * num_entities * len);
  if(list_occ[k] == NULL)
    fatal_error("Fatal error: --- out of memory in edit distance ----\n");
  
  
  // Search for 1 mismatch from <nomecoll>_entities.db
  t=0;
  temp_string[0]='\0';
  for(i=0; Get_actual_length(i,AND_pattern[k]) < len; i++){

    for(j=0; j<num_entities; j++){

      // Copy the first i macro-chars
      actual_len = Get_actual_length(i,AND_pattern[k]);
      strncpy(temp_string,AND_pattern[k],actual_len);
      temp_string[actual_len]=0;

      // Substitute the i-th char with the j-th entity
      strcat(temp_string,entities[j]);

      // Copy the rest of the pattern
      actual_len = Get_actual_length(i+1,AND_pattern[k]);
      if(actual_len<len)
	strcat(temp_string,AND_pattern[k]+actual_len);

      temp_list = search_dict(temp_string,strlen(temp_string),WFULL,&n);
      

      if(n>0){
	list_occ[k][t].rank = temp_list[0].rank;
	list_occ[k][t].row = temp_list[0].row;
	strcpy(list_occ[k][t].word,temp_string);
	t++;
      }
    }
  }
  


  // Search for 1 insertion from <nomecoll>_entities.db
  for(i=0; Get_actual_length(i,AND_pattern[k]) <= len; i++){

    for(j=0; j<num_entities; j++){

      // Copy the first i macro-chars
      actual_len = Get_actual_length(i,AND_pattern[k]);
      strncpy(temp_string,AND_pattern[k],actual_len);
      temp_string[actual_len]=0;

      // Insert in the i-th position the j-th entity
      strcat(temp_string,entities[j]);

      // Copy the rest of the pattern (if any)
      if(actual_len<len)
	strcat(temp_string,AND_pattern[k]+actual_len);

      temp_list = search_dict(temp_string,strlen(temp_string),WFULL,&n);
      
      if(n>0){
	list_occ[k][t].rank = temp_list[0].rank;
	list_occ[k][t].row = temp_list[0].row;
	strcpy(list_occ[k][t].word,temp_string);
	t++;
      }
    }
  }
  

  // Search for 1 deletion
  for(i=0; Get_actual_length(i,AND_pattern[k]) < len; i++){

    // Copy the first i macro-chars
    actual_len = Get_actual_length(i,AND_pattern[k]);
    strncpy(temp_string,AND_pattern[k],actual_len);
    temp_string[actual_len]=0;

    // Copy the rest of the pattern (jumping the i-th char)
    actual_len = Get_actual_length(i+1,AND_pattern[k]);
    if(actual_len<len)
      strcat(temp_string,AND_pattern[k]+actual_len);

    temp_list = search_dict(temp_string,strlen(temp_string),WFULL,&n);

    if(n>0){
      list_occ[k][t].rank = temp_list[0].rank;
      list_occ[k][t].row = temp_list[0].row;
      strcpy(list_occ[k][t].word,temp_string);
      t++;
    }
  }
  
  // Filter out the pattern occurrences which are not words
  c = 0;
  for(j=0; j < t; j++){
    if ((list_occ[k][j].rank <= Num_rank_end) ||
	(list_occ[k][j].rank >= Word_rank_start))
      {
	list_occ[k][c].rank = list_occ[k][j].rank;
	strcpy(list_occ[k][c].word,list_occ[k][j].word);   
	list_occ[k][c++].row = list_occ[k][j].row;
      }
  }
  
  if(c==0){
    number[k] = 0;           // number of cleaned occurrences
  } else {

    /* ---------  sort the ranks ------------- */
    qsort(list_occ[k], c, sizeof(dict_occ), rank_cmp);
    
    /* --------- Clean the list of occurrences ----------- */
    for(j=0, i=1; i < c; i++) {    // if list_occ[k][i] is not a duplicate ...
      if (list_occ[k][j].rank != list_occ[k][i].rank){ 
	list_occ[k][++j].rank = list_occ[k][i].rank;   // ... save it
	list_occ[k][j].row = list_occ[k][i].row;   
	strcpy(list_occ[k][j].word,list_occ[k][i].word);   
      } 
    }
    number[k] = j+1;           // number of cleaned occurrences
  }
  
}




/* -------------- Clean predefined entities into the pattern ------------- */
// num = # patterns, s = string to be substituted, 
// subst = string to be used in the substitution
void Clean_query_patterns(int num, uchar *s, uchar *subst)
{
  int i;
  uchar *c, *start, *end, *sstart;

  for(i=0; i<num; i++)
    {
      if(strstr(AND_pattern[i],s)){
	start = AND_pattern[i];
	end = start + strlen(start);
	sstart = start;
	AND_pattern[i] = (uchar *) malloc(sizeof(uchar) * (strlen(start)));
	AND_pattern[i][0] = 0;   // initialize as the empty string
	if(AND_pattern[i] == NULL)
	  fatal_error("Fatal error: ----- clean patterns -----\n");
	
	while((c=strstr(start,s)) != NULL){
	  strncat(AND_pattern[i],start,(int)(c-start));
	  strcat(AND_pattern[i],subst);
	  start = c+strlen(s);
	}
	if(start<end)
	  strcat(AND_pattern[i],start);
      }
    }
}

/* -------------- Change non alphanumeric char into X000 ------------- */
void Change_char_X(int num)
{
  int i,j,l;
  uchar temp[1000],*s;

  for(i=0; i<num; i++)
    {
      s=AND_pattern[i];
      for(j=0,l=0; j < (int)strlen(s); j++)
	{
	  if (isalnum(s[j]) && (s[j] != (uchar) 88))
	    {temp[l++] = s[j];}
	  else 
	    {sprintf(temp+l,"X%03d",s[j]); l+=4;}
	}
      temp[l]=0;
      AND_pattern[i]= strdup(temp);
    }
}


/* -------------- Change X000 into non alphanumeric char ------------- */
char *Inv_Change_char_X(char *s)
{
  uchar *temp = (uchar *) malloc(256);  
  int i,val;
  int j=0;
  int l=0;

  while(l < (int)strlen(s))
    {
      if (s[l] != 'X'){
	temp[j++]=s[l++];
      } else {
	for(i=1,val=0;i<=3;i++)
	  val = 10*val+((int)s[l+i] - 48);
	temp[j++]=(uchar)val;
	l += 4; // jump X000
      }
    }
  temp[j]=0;
  return temp;
}


/* ------------ Search for tag+cdata and/or pattern -------------- */
// It combines the tag (and CDATA separator <<<) with the pattern to search.
// Stores in list_occ the actual infos regarding to the occurrences and in
// num_occ their overall number.

void search_tag_cdata_pattern(char *tag_string,dict_occ **list_occ,int *num_occ,int npatt)
{
  int t,j,i,k;
  char temp_string[1000];
  dict_occ *temp_occ;

  if (npatt == 0) {  // just searching for tags
    temp_occ = search_dict(tag_string,strlen(tag_string),WFULL,&i);

    if(i>0){
      *list_occ = (dict_occ *) malloc(sizeof(dict_occ));
      sprintf(list_occ[0][0].word,"%s",tag_string);  // update word field
      list_occ[0][0].rank = temp_occ[0].rank;  // store the rank
      num_occ[0]=1;
    } else {num_occ[0]=0; }

  } else {

    for(k=0;k<npatt;k++){

      // For each word occurrence build the tag+word pattern to search
      for(t=0,j=0; j<num_occ[k]; j++){
	sprintf(temp_string,"%s%s",tag_string,list_occ[k][j].word);
	temp_occ = search_dict(temp_string,strlen(temp_string),WFULL,&i);
	
	// If there are occurrences of the tag+word combination
	if(i>0){
	  sprintf(list_occ[k][t].word,"%s",temp_string);  // update word field
	  list_occ[k][t++].rank = temp_occ[0].rank;  // store the rank
	}
      }
      num_occ[k]=t;
    }

  }
}


/* ------------ Search for tag+attr and/or pattern -------------- */
// It combines the tag infos with the attribute and search this string
// into the dictionary. Then searches for all the substring
// occurrences of the attribute value and filter all dictionary words
// which contain both.

// It uses the global variables Start_tag and End_tag.

void search_tag_attr_pattern(bwi_out *s, dict_occ **list_occ, int *num_occ)
{
  int t,j,r,c;
  uchar word_prefix[500],word_suffix[500];
  uchar *p;


  list_occ[0] = search_dict(Attr_value,strlen(Attr_value),WSUBSTRING,num_occ);

  // Filter out the occurrences of the Attribute value which do not lie
  // in the same dictionary word as the ones prefixed by the tag_string
  t = 0;
  for(j=0; j<num_occ[0]; j++){

    if ((list_occ[0][j].rank >= Start_tag) &&
	(list_occ[0][j].rank <= End_tag))
      {
	list_occ[0][t].rank = list_occ[0][j].rank;
	list_occ[0][t].row = list_occ[0][j].row;
	
	// Construct the entire string containing the answer
	get_prefix_word(list_occ[0][t].row, &c, word_prefix, s);
	for(r=0; r<c; r++)
	  list_occ[0][t].word[r] = word_prefix[c-r-1];
	list_occ[0][t].word[c] = 0;
	strcat(list_occ[0][t].word,Attr_value);
	get_suffix_word(list_occ[0][t].row, &c, strlen(Attr_value),
			word_suffix, s);
	strncat(list_occ[0][t].word,word_suffix,c);

	// Avoid case Attr_value occurs inside tag_name or attr_name
	p=strstr(list_occ[0][t].word,"=");
	if(strstr(p+1,Attr_value) != NULL)  // It is a correct occurrence
	  t++;
      }
  }
  num_occ[0]=t;
}


/* ------------ AND of at most MAX_AND_PATTERNS patterns -------------- */
// Allocate a new list *L3 large enough to contain the intersection of
// L1 and L2.  Lists L1 and L2 should be freed after this calling.

void And_two_lists(docs_occ *L1, int n1, docs_occ *L2, int n2, docs_occ **L3, int *n3)
{
  int i1,i2,temp_doc;

  *n3=0;
  *L3 = (docs_occ *) malloc(sizeof(docs_occ) * (n1+n2));
  if(*L3 == NULL)
    fatal_error("Fatal error: out of memory in AND\n");

  for(i1=0,i2=0;(i1<n1) && (i2<n2); )
    {
      if(L1[i1].doc == L2[i2].doc){
	temp_doc = L1[i1].doc;
	while((i1<n1) && (L1[i1].doc == temp_doc)){
	  (*L3)[*n3].doc = L1[i1].doc;
	  (*L3)[*n3].pattnum = L1[i1].pattnum;
	  strcpy((*L3)[*n3].word,L1[i1].word);
	  (*L3)[*n3].word[strlen(L1[i1].word)] = 0;
	  (*n3)++; i1++; }
	while((i2<n2) && (L2[i2].doc == temp_doc)){
	  (*L3)[*n3].doc = L2[i2].doc;
	  (*L3)[*n3].pattnum = L2[i2].pattnum;
	  strcpy((*L3)[*n3].word,L2[i2].word);
	  (*L3)[*n3].word[strlen(L2[i2].word)] = 0;
	  (*n3)++; i2++; }
      } else { 
	if(L1[i1].doc < L2[i2].doc){i1++;} else {i2++;}
      }
    }
}

/* ------------ OR of the lists of a pattern occurrence -------------- */
// A pattern may occur in various forms. We allocate a new list large
// enough to contain the merged elements.  List L keeps n occurrences
// of variants of a pattern whose docs must be retrieved.  The overall
// set of docs of size *nn, is stored in a list pointed by *LL

void Merge_lists(dict_occ *L, int n, WorkFiles *wfile, docs_occ **LL, int *nn)
{

  int i,j,*l1,n1;
  docs_occ *ltemp;

  LL[0] = NULL;
  *nn=0;

  // L points to the n variants of a given word in the dictionary
  for(i=0; i<n; i++){  

    // Get the Inverted List for a given word rank
    l1 = GetInvList(L[i].rank,wfile);
    n1 = *l1++;  // get #docs in IL and moves its head

    ltemp = (docs_occ *) malloc(sizeof(docs_occ) * (n1+*nn));
    if(ltemp == NULL)
      fatal_error("Fatal error: memory overflow at OR\n");

    // Copies already found occs
    for(j=0; j<*nn; j++){
      ltemp[j].doc = LL[0][j].doc;
      strcpy(ltemp[j].word,LL[0][j].word);
      ltemp[j].word[strlen(LL[0][j].word)] = 0;  }

    // Copies occs of the i-th word
    for(j=*nn; j<n1+*nn; j++){
      ltemp[j].doc = l1[j-*nn];
      strcpy(ltemp[j].word,L[i].word);   
      ltemp[j].word[strlen(L[i].word)] = 0;   }

    if (LL[0] != NULL) free(LL[0]);
    LL[0]=ltemp; *nn += n1;
  }
  
  /* ---------  sort the docs ------------- */
  qsort(LL[0], *nn, sizeof(docs_occ), doc_cmp);
}





void Getdocs(dict_occ **list_occ_word, int *num_occ_word, int num_patterns, 
	     docs_occ **L, int *n, WorkFiles *Index_files)
{
  docs_occ *Ltemp1, *Ltemp2;
  int ntemp1,ntemp2;
  int i,j;
  
  *L=NULL; *n=0;
  Ltemp1=NULL; ntemp1=0;
  Ltemp2=NULL; ntemp2=0;


  Merge_lists(list_occ_word[0],num_occ_word[0],Index_files, L, n);
  for(j=0; j<*n; j++)
    (*L)[j].pattnum = 0;
  
  if(num_patterns>1){  // In case of many patterns

    And_two_lists(*L,*n,Ltemp1,ntemp1,&Ltemp2,&ntemp2);    

    for(i=1;i<num_patterns;i++){  

      Merge_lists(list_occ_word[i],num_occ_word[i],Index_files, 
		  &Ltemp1, &ntemp1); 

      for(j=0; j<ntemp1; j++)
	Ltemp1[j].pattnum = i;

      And_two_lists(*L,*n,Ltemp1,ntemp1,&Ltemp2,&ntemp2);    

      
      // Free the unused memory
      if (*L != NULL) free(*L);
      if (Ltemp1 != NULL) free(Ltemp1);
      
      // L contains the list of triples (docs,words,patt_num) answering the query
      // It has total length n
      *L=Ltemp2; *n=ntemp2;
    }
  }

  // Find File_names for the docs where the words occur
  // Names relative to HOME_FMX/Collections, or equally, HOME_FMX/Reduced
  FillFilename(*L,*n,Index_files);
}





// -----------------------------------------------
// ----------- main procedure for xml search -----
// -----------------------------------------------
int main(int argc, char *argv[])
{
  int getopt(int argc, char * const *argv, const char *options);
  extern char *optarg;
  extern int optind, opterr;
  int num_opt;

  uchar *pattern,tag_string[300];     //255 = Maximum pattern length
  int i,j,c;
  dict_occ *list_occ_word[MAX_AND_PATTERNS];
  int num_occ_word[MAX_AND_PATTERNS];
  docs_occ *L;
  int n;

  bwi_out s_main;
  bwi_out *s = &s_main; 
  uchar Curr_mask = 0;
  int num_patterns = 0;
  int verbose=0;
  int location=0;
  int proximity = 10;

  char *home_path;
  char *collection_name;
  char *Extension_string;
  char temp_name[255];
  WorkFiles Index_files;

  if(argc<3) {
    fprintf(stderr, "Usage:\n\t%s ",argv[0]);
    fprintf(stderr,"[-x 1|2|3][-o path][-v][-l][-s #words]\n\t");
    fprintf(stderr,"                           [-C][-T htag][-t ltag]\n\t");
    fprintf(stderr,"                           [-A attr_name][-V attr_value]\n\t");
    fprintf(stderr,"                           [-w (0|1|2|3|4)^k] pattern1..patternk bwifile\n");
    fprintf(stderr,"Valid options are:\n");
    fprintf(stderr,"\t-x   data access: 1=Ext, 2=Mmap, 3=In (default 1)\n");
    fprintf(stderr,"\t-X   string appended to file names <fmx_occs> and <fmx_sum>\n");
    fprintf(stderr,"\t-o   specifies the path of the HOME_FMX directory (if $HOME_FMX not set, then .)\n");
    fprintf(stderr,"\t-v   output word+docs and write them in fmx_sum.dat (if >2 times, many infos)\n");
    fprintf(stderr,"\t-l   write in fmx_occs.dat a sequence of <line doc words> (in *reduced*)\n");
    fprintf(stderr,"\t-s   proximity value in #words (default 10, not smaller)\n");
    fprintf(stderr,"\t-C   CDATA restriction (with t and/or pattern)\n");
    fprintf(stderr,"\t-T   enclosing higher tag (with t)\n");
    fprintf(stderr,"\t-t   enclosing lower tag (with one pattern or -T or -VA)\n");
    fprintf(stderr,"\t-A   attribute name (with tV)\n");
    fprintf(stderr,"\t-V   attribute value (with tA)\n");
    fprintf(stderr,"\t-w   type of pattern search: 0=Subs 1=Pfx 2=Sfx 3=Full 4=One Error\n\n\n");
    fprintf(stderr,"Details: There are two files <fmx_occs.dat> and <fmx_sum.dat>");
    fprintf(stderr," which contain the <line doc words> occurrences and the <doc words> detail,"); 
    fprintf(stderr," respectively. These files are stored in $HOME_FMX/Working/. One can");
    fprintf(stderr," extend these names with a string specified via -X.\n");
    fprintf(stderr,"The *one-error* option allows to search for one-edit distance patterns.");
    fprintf(stderr," The items to be ins/subst are listed in the file <nomecoll>_entities.db that");
    fprintf(stderr," is stored in $HOME_FMX/Index/<nomecoll>/. Its template is");
    fprintf(stderr," available in $HOME_FMX/configurations. Strings are parsed as sequences");
    fprintf(stderr," of entities and characters.\n");
    exit(1);
  }

  /* ----------------- read options --------------------- */
  collection_name=NULL;
  num_opt = opterr=0;
  Type_mem_ops = EXT_MEM;
  Cache_percentage = 0;

  if(getenv("HOME_FMX") != NULL)
    {home_path = strdup(getenv("HOME_FMX"));}
  else {home_path="./";}


  /* ----------------- search options --------------------- */
  Htag = NULL;
  Ltag = NULL;
  Attr_name=NULL;
  Attr_value=NULL;
  pattern =NULL;
  AND_string_type="";
  num_patterns = 0;
  Extension_string = "";

  while ((c=getopt(argc, argv, "vlo:s:CT:t:A:V:w:x:X:")) != -1) {
    switch (c)
    {
    case 'v':
      verbose++; break;
    case 'o':
      home_path=optarg; break;
    case 'l':
      location=1; break;
    case 's':
      location=1; 
      proximity = atoi(optarg); break;
    case 'x':
      Type_mem_ops = atoi(optarg); break;
    case 'X':
      Extension_string = optarg; break;
    case 'T':
      Htag=optarg; Curr_mask |= Htag_mask; break;
    case 't':
      Ltag=optarg; Curr_mask |= Ltag_mask; break;
    case 'C':
      Curr_mask |= Cdata_mask; break;
    case 'A':
      Attr_name=optarg; Curr_mask |= Attr_name_mask; break;
    case 'V':
      Attr_value=optarg; Curr_mask |= Attr_value_mask;break;
    case 'w':
      AND_string_type = optarg; 
      num_patterns = strlen(AND_string_type); 
      Curr_mask |= AND_mask;
      break;
    case '?':
      fatal_error("Fatal error: Unknown option -main-\n");
    }
    num_opt++;
  }



  /* ------- check consistency of the options ---------- */
  if(optind == argc)
    fatal_error("Fatal error: You must supply a filename!\n");
  if((Type_mem_ops<1) || (Type_mem_ops>3))
    fatal_error("Fatal error: Invalid data access option\n");
  if((num_patterns<0) || (num_patterns>9)) 
    fatal_error("Fatal error: Invalid number of patterns to search\n");
  if((proximity>0) && (proximity < 10))
    fatal_error("Fatal error: Proximity value must be greater than 10\n");

  /* -------- Determines the type of the search ------- */
  for(i=0;(i<NUM_MASKS) && (Curr_mask != Search_mask[i]);i++) ;
  if(i==NUM_MASKS)
    fatal_error("Fatal error: --- no correct search arguments ! ---\n");


  /* ------- read and check patterns --------- */  
  if((num_patterns > 0) && (optind != argc - num_patterns - 1))
    fatal_error("Fatal error: Supply correct # patterns and the filename!\n");
  for(i=0; i<num_patterns; i++){
    AND_pattern[i] = (uchar *) argv[optind++];
    AND_type_search[i] = ((int)(AND_string_type[i]) - '0');  
    if(AND_type_search[i] > ERRORLETTER)
      fatal_error("Fatal error: -w string must contain 0..4\n"); 
    if((strlen(AND_pattern[i]) <=1) && (AND_type_search[i]>WFULL))
      fatal_error("Fatal error: with option 4, pattern length > 1\n");
  }

  /* ------- read collection name and HOME_FMX variable --------- */  
  collection_name = (char *) argv[optind];

  sprintf(temp_name,"%s/Index/%s/%s.dict.bwi",home_path,collection_name,collection_name);
  my_open_file(temp_name);  // Infile is the Dictionary file

  sprintf(temp_name,"%s/Index/%s",home_path,collection_name);
  Index_files = OpenFiles(temp_name,collection_name);
  
  /* ---------  Initialize the Cache System ------------- */
  init_bwi_cache();  

  // ------ Dictionary can be divided into three parts:
  //  1. words starting with a digit
  //  2. strings starting with '<' and referring to tags or CDATA
  //  3. words starting with a letter
  // We therefore identify rank-boundaries of the words as follows:
  //    a. Load starting rank of words beginning with '<' (i.e. tags or CDATA)
  //    b. Load ending rank of words beginning with '<'  (i.e. tags or CDATA)
  // These two ranks suffice to compute the  ranks of
  //    i.  The last word beginning with a digit
  //    ii. The first word beginning with a letter
  //---------------------------------------------------
  read_basic_prologue(s);
  tag_string[0] = '<';
  tag_string[1] = 0;  // end string
  n=search_pattern_dict(s,tag_string,1,&i,&j,WPREFIX);
  if (n>0) {
    Num_rank_end = get_rank(s,i)-1;
    Word_rank_start = get_rank(s,j)+1;
  } else {
    fatal_error("Fatal error: The dictionary does not contain any tag....\n");
  }

  /* ------- Build the string = tag + attribute to search into the dictionary ------- */
  Build_tagstring(Curr_mask,tag_string);
  n=search_pattern_dict(s,tag_string,strlen(tag_string),&i, &j,WPREFIX);
  if (n>0){
    Start_tag=get_rank(s,i);  
    End_tag=get_rank(s,j);
  } else {
    Start_tag = -1;
    End_tag = -2;
  }

  /* ------- Build and search the set of patterns into the dictionary ------- */
  // List_occ_words[0..MAX_AND_PATTERNS-1] keeps the infos about their
  // occurrences distinguished for each pattern of the query.
  // num_occ_word[MAX_AND_PATTERNS] keeps information about their
  // number for each pattern.

  if (num_patterns > 0) {

    // A maquillage on the patterns to clean special chars
    // An ambiguity may arise if the pattern contains ....&amp;xx;....
    // in this case the parser changes into .....&xx;.... hence xx becomes an entity !
    // Usually patterns are composed by entities and letters, so no problem.
    // To be elegant we should "cancel" singleton ; in the text.
    Clean_query_patterns(num_patterns,"&lt;","<");
    Clean_query_patterns(num_patterns,"&gt;",">");
    Clean_query_patterns(num_patterns,"&quot;","\"");
    Clean_query_patterns(num_patterns,"&apos;","\'");
    Clean_query_patterns(num_patterns,"&amp;","&");
    Change_char_X(num_patterns); 

    for(i=0; i<num_patterns; i++)
      if(AND_type_search[i] == ERRORLETTER)   // Search for the i-th erroneous pattern
	{Build_erroneous_pattern(i,num_occ_word,list_occ_word,home_path,collection_name);}
      else 
	{Build_pattern(s,i,num_occ_word,list_occ_word);} 
                  // *s is needed to reconstruct entire words
  }


  /* Some useful debugging informations */
  if(verbose>1){
    printf("End-rank of numbers = %d, Start-rank of words = %d\n",
	   Num_rank_end,Word_rank_start);

    printf("Tag string %s, start-rank = %d, end-rank = %d\n\n\n",
	   tag_string,Start_tag,End_tag);

    for(i=0;i<num_patterns;i++){
      if(num_occ_word[i]==0)
	printf("  Not found pattern = %s\n", AND_pattern[i]);
      for(j=0;j<num_occ_word[i];j++)
	printf("  Found string = %s  of pattern = %s as %s, with rank %d\n",
	       list_occ_word[i][j].word,AND_pattern[i],
	       Type_search[AND_type_search[i]],list_occ_word[i][j].rank);
    }
  }

  printf("\n\n");

  /* --- Main search step: 
     list_occ_word[i] is the list of occurrences of (combined) strings. 
     num_occ_word[i] is the length of list_occ_word[i]. 
     --- */

  switch(Curr_mask){
    
  case 22:  // Case of Attribute searches: num_word_occ[0] is the only defined
    search_tag_attr_pattern(s,list_occ_word,num_occ_word);
    break;

  case 64: // Case of Multi-pattern searches: word occs already found above
    break;
    
  default: // All other cases: a tag string + (maybe) CDATA + (maybe) some patterns    
    search_tag_cdata_pattern(tag_string,list_occ_word,num_occ_word,num_patterns);
    break;
  }

  // Resolve the query by possibly executing the AND among all pattern-docs
  //
  // L[i].doc_name = document containing a pattern, path relative to HOME_FMX/Collections/
  // L[i].doc = number of the document containing a pattern
  // L[i].pattnum = pattern number occurring in that doc.
  // L[i].word = word verion of the "L[i].pattnum"-th pattern (possibly <tag#pattern or others).
  Getdocs(list_occ_word,num_occ_word,num_patterns,&L,&n,&Index_files);

  /* ------------------------ Cleaning of the results ----------------------------- */

  // Patch: MG divides files longer than 3Mb hence a file may
  //        occur with different numbers (consecutive).


  // Assign the same doc number (the first)
  for(i=1;i<n;i++)
    if(strcmp(L[i].doc_name,L[i-1].doc_name) == 0)
      L[i].doc = L[i-1].doc;

  // Contiguous occurrences of the same word in the same doc
  qsort(L, n, sizeof(docs_occ), doc_word_name_cmp);

  for(j=0, i=1; i < n; i++) {
    if ((L[i].doc != L[j].doc) || (strcmp(L[i].word,L[j].word) != 0)){  // Not a duplicate ...
      j++;
      if (i != j){
	L[j].doc = L[i].doc;
	strcpy(L[j].word,L[i].word);
	strcpy(L[j].doc_name,L[i].doc_name);
	L[j].pattnum = L[i].pattnum;
      }
    }
  }

  // Notice that at this point L[i].word may be a complex string
  // since it is prefixed also by CDATA or tag infos
  if (n!=0) n=j+1;  //actual number of occurrences


  /* ------------------------ Output the results ----------------------------- */
  {
    FILE *f;
    char temp_file[256], temp_file1[256], output_results[256],output_summary[256];
    char command[2000], command1[2000];
    char tag[256];
    
    sprintf(output_summary,"%s/Working/fmx_sum%s.dat",home_path,Extension_string);
    sprintf(output_results,"%s/Working/fmx_occs%s.dat",home_path,Extension_string);
    sprintf(temp_file,"%s/Working/temp_fmx1%s.dat",home_path,Extension_string);
    sprintf(temp_file1,"%s/Working/temp_fmx2%s.dat",home_path,Extension_string);

    // Removes temporary and result files
    sprintf(command,"rm -f %s %s %s %s",
	    output_summary,output_results,temp_file,temp_file1);
    system(command);

    // Creates an empty file to manage the case of no-occurrences
    sprintf(command,"echo -n \"\" > %s; echo -n \"\" > %s",
	    output_results,output_summary);
    system(command);

    /* ----- Write the SUMMARY file ---- */
    if(verbose) {
      f = fopen(output_summary,"w");
      
      for(i=0;i<n;i=j){
	fprintf(f,"\n\nFile: %s\nWords: ",L[i].doc_name);
	fprintf(f,"%s ",Inv_Change_char_X(L[i].word));
	
	for(j=i+1; (j<n) && (L[j].doc == L[j-1].doc); j++)
	  fprintf(f,"%s ",Inv_Change_char_X(L[j].word));
      }
      fclose(f);

      sprintf(command,"cat %s",output_summary);
      system(command);
    }

    /* ----- Write the LINE-OCCURRENCE file ----- */
    if(location) {
    
      for(i=0;i<n;i=j){
      
	// Remove working files
	sprintf(command,"rm -f %s %s",temp_file,temp_file1);
	system(command);
      
      
	// Process one distinct document at time (taking its .red version)	
	// Output structure: <lineofoccurrence> <pattnum> <string>
	for(j=i;(j<n) && (L[j].doc == L[i].doc);j++){
	
	  sprintf(command,"grep -w -n \"^%s\" %s/Reduced/%s.red",L[j].word,home_path,L[j].doc_name);
	  sprintf(command1,"|awk -F: '{printf(\"%%010d %%d %%s\\n\",$1,%d,\"%s\");}' >> %s",
		  L[j].pattnum,Inv_Change_char_X(L[j].word),temp_file); 
	  strcat(command,command1);
	  system(command); }
	
	// Sort by row number the occurrences of (possibly many) word(s) in L[i].doc
	sprintf(command,"sort %s > %s; mv -f %s %s",
		temp_file,temp_file1,temp_file1,temp_file);
	system(command);

	// Produce a file having structure: <lineofoccurrence> <docname> <word1>....<wordk>
	switch(Curr_mask){
	  
	case 64: // Case of Multi-pattern searches: word occs already found above
	  
	  // Select proximal rows
	  sprintf(command,"awk 'BEGIN {for(i=0;i<%d;i++) OCC[i] = -5000}", num_patterns);
	  strcat(command,"{OCC[$2] = $1; WOCC[$2] = $3; min = 700000000; max = -1;");
	  sprintf(command1,"for(i=0;i<%d;i++){if(OCC[i]>max) max=OCC[i]; if(OCC[i]<min) min=OCC[i];};",
		  num_patterns);
	  strcat(command,command1);
	  sprintf(command1,"if((max-min)<= %d){ printf(\"%%d %%s \", (min+max)/2, \"%s\");",
		  proximity,L[i].doc_name);
	  strcat(command,command1);
	  sprintf(command1,"for(i=0;i<%d;i++){printf(\"%%s \", WOCC[i]);}; printf(\"\\n\");  };}' %s >> %s",
		  num_patterns,temp_file,output_results);
	  strcat(command,command1);
	  system(command);
	  break;
	  
	case 80: // Case of Tag + pattern(s)


	  // Select proximal rows
	  sprintf(command,"awk 'BEGIN {for(i=0;i<%d;i++) OCC[i] = -5000}", num_patterns);
	  strcat(command,"{OCC[$2] = $1; WOCC[$2] = $3; min = $1+1; max = -1;");
	  sprintf(command1,"for(i=0;i<%d;i++){if(OCC[i]>max) max=OCC[i]; if(OCC[i]<min) min=OCC[i];};",
		  num_patterns);
	  strcat(command,command1);
	  sprintf(command1,"if((max-min)<= %d){for(i=0;i<%d;i++){printf(\"%%010d %%d %%s\\n\", OCC[i], i, WOCC[i]);};}}' %s >> %s",proximity,num_patterns,temp_file,temp_file1);
	  strcat(command,command1);
	  system(command);

	  sprintf(command,"sort %s | uniq > %s", temp_file1,temp_file);
	  system(command);

	  // Build the string <tag&>  to detect the beginning of the TAG environment
	  strcpy(tag,tag_string);
	  tag[strlen(tag)-1]='&';
	  tag[strlen(tag)]='>';
	  tag[strlen(tag)+1]=0;

	  // Add infos about tag openings
	  sprintf(command,"grep -w -n \"^%s\" %s/Reduced/%s.red",tag,home_path,L[i].doc_name);
	  sprintf(command1,"|awk -F: '{printf(\"%%010d %%d %%s\\n\",$1,-1,\"%s\");}' >> %s",tag,temp_file); 
	  strcat(command,command1);
	  system(command);
	  sprintf(command,"echo \"1000000000 -1 %s\" >> %s",tag,temp_file); // append ending tag to flush
	  system(command);

	  // Sort by row number the occurrences (one pair doc-tag may be listed many times, hence uniq)
	  sprintf(command,"sort %s | uniq > %s; mv -f %s %s",
		  temp_file,temp_file1,temp_file1,temp_file);
	  system(command);

	  // Select rows <line> <pattnum> <string> 
	  // referring to the same tag (no re-open)
	  sprintf(command,"awk 'BEGIN {for(i=0;i<%d;i++) OCC[i] = -1;}", num_patterns);
	  strcat(command,"{if ($2 != -1){OCC[$2] = $1; WOCC[$2] = $3;}");
	  sprintf(command1,"else {n=0; for(i=0;i<%d;i++){if(OCC[i]==-1) n++;};",num_patterns);
	  strcat(command,command1);
	  sprintf(command1,"if(n==0){printf(\"%%d %%s \", OCC[0], \"%s\");",L[i].doc_name);
	  strcat(command,command1);
	  sprintf(command1,"for(i=0;i<%d;i++){printf(\"%%s \", WOCC[i]);}; printf(\"\\n\");};",num_patterns);
	  strcat(command,command1);
	  sprintf(command1,"if(n!=0){for(i=0;i<%d;i++){OCC[i]=-1;}}}}' %s >> %s",num_patterns,temp_file,output_results);
	  strcat(command,command1);
	  system(command);
	  break;
      
	default: // All other cases

	  // No filtering
	  sprintf(command,"awk '{print $1, \"%s\", $3}' %s >> %s",
		  L[i].doc_name,temp_file,output_results);
	  system(command);
	  break;
	}

      // Remove the temporary files
      sprintf(command,"rm -f %s %s",temp_file,temp_file1);
      system(command);
      }
    }
  }

  my_fclose(Infile);
  CloseFiles(&Index_files);
  return 0;
}


